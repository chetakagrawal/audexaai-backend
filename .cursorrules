# Cursor Project Rules — Backend
FastAPI · Python 3.13 · Poetry · PostgreSQL · SQLAlchemy 2.x (async) · Alembic · JWT

================================================================

## 1. Non-negotiables (highest priority)
- Strict TDD: tests first → minimal code → refactor.
- No tests = not done.
- Tests define the contract in development (no backward-compat guarantees).
- Production-grade code only; no placeholders or TODOs unless explicitly requested.
- Rules apply to production code under api/, services/, repos/, models/, schemas/, core/, and tests.
  They do not apply to docs, tooling scripts, or migrations beyond safety rules.

================================================================

## 2. Architecture & layering
api/        → routers, request/response schemas, auth dependencies  
services/   → business logic only  
repos/      → DB access only  
models/     → SQLAlchemy models  
schemas/    → Pydantic DTOs  
core/       → config, security, logging  

Rules:
- Routers → Services → Repos → Database
- No database access in routers.
- No HTTP concepts in services or repos.
- Services must be framework-agnostic.
- services/ must not import from api/.
- repos/ must not import from api/ or services/.
- api/ may import schemas/ and call services/ only.

================================================================

## 3. Design references (source of truth)
- docs/architecture/erd.md
- docs/architecture/erd_explained.md
- docs/architecture/multi_tenant_architecture.md

Rules:
- ERD is a reference, not a schema generator.
- Schema changes must move incrementally toward the ERD.
- Never generate all tables from the ERD in a single migration.

================================================================

## 4. Multi-tenant safety (critical)
Every request must resolve:
- User
- Membership (UserTenant.id)
- Tenant (derived)

Rules:
- Never accept tenant_id from client input.
- Tenant resolution happens in an auth dependency and is passed to services as context.
- Every tenant-owned table must include tenant_id.
- Tenant-scoped ownership must reference UserTenant.id.
- All tenant-scoped queries must filter by tenant_id.
- Unique business keys must be composite: UNIQUE(tenant_id, business_key).
- Cross-tenant access must be explicitly tested and blocked.

================================================================

## 5. Database rules
- SQLAlchemy async only.
- Sessions provided via dependency injection.
- Use `async with session.begin():` for multi-step writes.
- Required indexes for tenant-owned tables must match query patterns:
  - (tenant_id, <lookup_key>) where <lookup_key> is frequently filtered or sorted.

================================================================

## 6. Alembic & migrations
- Any model change requires a migration.
- Migrations must be small, explicit, and reversible.
- Pattern for required columns:
  1) add nullable
  2) backfill
  3) enforce NOT NULL + FK + index
- Never combine unrelated schema changes in one migration.

================================================================

## 7. Auth & JWT
- JWT logic lives in core/security.py.
- Never log tokens, secrets, or credentials.

Required tests:
- valid token accepted
- invalid or expired token rejected
- cross-tenant access blocked

================================================================

## 8. Testing (testing pyramid enforced)

### 8.0 Default pyramid
- services/ + core/: unit tests (primary confidence)
- api/: integration tests in `tests/integration/` + unit tests in `tests/unit_tests/`
- models/: DB-backed tests in `tests/models/` (required for all new models)
- repos/: DB-backed tests only for non-trivial queries and tenant enforcement

### 8.1 Tooling
- pytest + pytest-asyncio + httpx.AsyncClient
- Ephemeral PostgreSQL preferred.
- No real network calls.
- Deterministic tests only (no wall-clock dependence).

### 8.2 Unit tests (required)
Rules:
- Every change to services/ requires unit tests covering:
  - happy path
  - at least one edge case
  - at least one error or exception path
- Every change to core/ utilities requires unit tests.
- Unit tests may mock:
  - repos when testing services
  - time, uuid, randomness, or external integrations
- Unit tests must not:
  - touch the database
  - start an HTTP server
  - perform network I/O

Do NOT unit test:
- Routers (covered via integration tests).
- SQLAlchemy internals unless the code is pure query-building.

### 8.3 Integration tests (required for endpoints)
For every API endpoint added or changed:
- happy path
- auth failure (missing, invalid, or expired token)
- validation failure
- tenant isolation (cross-tenant access blocked)

**Location**: All endpoint integration tests must be in `tests/integration/` directory.

**Note**: Integration tests test the full HTTP request/response cycle via `httpx.AsyncClient`.
These tests verify the complete endpoint behavior including routing, auth, validation, and responses.

### 8.4 Unit tests for endpoints (required for new endpoints)
**Location**: All endpoint unit tests must be in `tests/unit_tests/` directory.

**File naming**: `tests/unit_tests/test_<endpoint_name>_<http_method>.py` or `test_<router_name>_endpoints.py`
(e.g., `test_signup_post.py` or `test_signup_endpoints.py` for signup endpoints)

**Required when adding a new endpoint**:
Every new API endpoint requires unit tests covering:
- Handler function logic (if extracted from router)
- Request validation and parsing
- Response serialization
- Error handling and exception paths
- Business logic specific to the endpoint (if not in services/)
- Edge cases in request processing

**Test structure**:
- Mock dependencies (database, services, auth, etc.)
- Test handler/endpoint functions in isolation
- Use `pytest` with standard fixtures
- Do NOT start HTTP server or make real network calls
- Focus on testing the endpoint's business logic and validation

**Separation from integration tests**:
- **Unit tests** (`tests/unit_tests/`): Test endpoint logic in isolation with mocks
- **Integration tests** (root `tests/`): Test full HTTP request/response via `httpx.AsyncClient`

**Do NOT create an endpoint without both unit AND integration tests** - No tests = not done.

### 8.5 Repo / DB tests (focused)
Write DB-backed tests only for:
- non-trivial queries (filters, joins, ordering, pagination)
- tenant_id enforcement
- uniqueness or business-key behavior

Avoid testing trivial CRUD plumbing.

### 8.6 Model tests (required for new models)
**Location**: All model tests must be in `tests/models/` directory.

**File naming**: `tests/models/test_<model_name>.py` (e.g., `test_signup.py` for Signup model)

**Required when adding a new model**:
Every new SQLAlchemy model requires DB-backed tests covering:
- Minimal creation (required fields only)
- Full field population (all optional fields)
- Field defaults and nullable behavior
- Database constraints (unique, foreign keys, etc.)
- Query patterns for indexed fields
- Relationships (if applicable)
- Timestamp behavior (created_at, updated_at)

**Test structure**:
- Use `db_session` fixture from `tests/conftest.py`
- Tests use real database session (DB-backed, not unit tests)
- Follow pattern: Create → Verify → Query → Assert
- See `tests/models/test_signup.py` as reference implementation

**Do NOT create a model without tests** - No tests = not done.

### 8.7 Definition of done (tests)
- No tests = not done applies to:
  - **new models** (must include tests in `tests/models/`)
  - **new endpoints** (must include both unit tests in `tests/unit_tests/` AND integration tests in `tests/integration/`)
  - service logic
  - endpoint changes
  - complex repository queries
- Tests must pass locally and in CI.

================================================================

## 9. Error handling
- Centralized exception handlers only.
- Consistent error response shape:
{
  "error": {
    "code": "...",
    "message": "...",
    "details": ...
  }
}

================================================================

## 10. Code quality
- Type hints required on all public functions.
- Prefer fixing types over introducing Any.
- Small, readable functions.
- Structured logging only.
- No leftover TODOs or commented-out code.

================================================================

## 11. Required self-check (must be included in final response)
1) Files changed
2) How to run tests
3) Migrations added (if any)
4) Tenant isolation verified
5) Auth behavior verified

================================================================

## 12. Task template
Task: Implement <feature> using strict TDD.

Steps:
1) Write failing tests
2) Implement minimal code
3) Add edge + tenant tests
4) Add migration if needed
5) Final summary + self-check

================================================================

## 13. Formatting, linting, and type-checking (required)

Tools:
- ruff (lint + formatting)
- mypy (type checking)

Rules:
- Code must pass:
  - `poetry run ruff check .`
  - `poetry run ruff format --check .`
  - `poetry run mypy .`
- If modifying Python files, fix all lint and format issues introduced by the change.
- Do not suppress rules with `# noqa` or `type: ignore` unless:
  1) a clear justification comment is included, and
  2) no safer refactor exists.

CI expectation:
- Lint, format, and type checks must run in CI and block merge on failure.

Final response must include:
- Lint and type-check commands run (or exact commands to run)
